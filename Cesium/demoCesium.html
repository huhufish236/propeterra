<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>demoCesium</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.106/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.106/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style type="text/css">
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    /* Generic panel style */
    .panel {
      position: absolute;
      background: linear-gradient(135deg, rgba(16, 20, 40, 0.95) 0%, rgba(32, 36, 60, 0.95) 100%);
      color: #e0e7ff;
      border-radius: 8px;
      font-family: "Roboto", Arial, sans-serif;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(81, 162, 255, 0.2);
      z-index: 999;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(81, 162, 255, 0.3);
    }

    .panel::before {
      content: "";
      position: absolute;
      top: -1px; left: -1px; right: -1px; bottom: -1px;
      border-radius: 8px;
      padding: 1px;
      background: linear-gradient(135deg, #51a2ff, #2c76dc, #0f4c9c);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor;
      mask-composite: exclude;
      pointer-events: none;
      z-index: -1;
    }

    .panel .header {
      font-family: "Orbitron", sans-serif;
      font-size: 16px;
      font-weight: 500;
      text-align: center;
      color: #51a2ff;
      letter-spacing: 1px;
      text-shadow: 0 0 10px rgba(81, 162, 255, 0.5);
    }

    /* Info panel */
    #infoPanel {
      top: 10px;
      right: 10px;
      width: 320px;
      padding: 0;
      font-size: 14px;
      display: none;
      max-height: 80%;
      overflow-y: auto;
      transform: translateY(-10px);
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
    }
    #infoPanel.visible {
      transform: translateY(0);
      opacity: 1;
      box-shadow: 0 15px 30px rgba(0,0,0,0.6), 0 0 0 1px rgba(81,162,255,0.4), 0 0 15px rgba(81,162,255,0.3);
    }
    #infoPanel .header {
      background: linear-gradient(90deg, rgba(16, 20, 40, 0.8) 0%, rgba(32, 36, 60, 0.8) 100%);
      border-bottom: 1px solid rgba(81,162,255,0.3);
      padding: 12px 15px;
      margin-bottom: 0;
      border-radius: 8px 8px 0 0;
      position: relative;
    }
    #infoPanel .header::before,
    #infoPanel .header::after {
      content: "";
      position: absolute;
      top: 0;
      width: 40px;
      height: 3px;
      border-radius: 3px;
    }
    #infoPanel .header::before {
      left: 15px;
      background: linear-gradient(90deg, #51a2ff, transparent);
    }
    #infoPanel .header::after {
      right: 15px;
      background: linear-gradient(90deg, transparent, #51a2ff);
    }
    #infoPanel .close-btn {
      position: absolute;
      top: 12px;
      left: 12px;
      cursor: pointer;
      background: none;
      border: none;
      color: #51a2ff;
      font-size: 16px;
      width: 24px; height: 24px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
      z-index: 2;
    }
    #infoPanel .close-btn:hover {
      color: #fff;
      background: rgba(81,162,255,0.2);
      box-shadow: 0 0 10px rgba(81,162,255,0.5);
    }
    #propertyContent {
      padding: 10px 15px;
      position: relative;
    }
    #propertyContent::before {
      content: "";
      position: absolute;
      top: 0; left: 10px; width: 2px; height: 100%;
      background: linear-gradient(to bottom, transparent, rgba(81,162,255,0.3), transparent);
    }
    #infoPanel .property-row {
      display: flex; justify-content: space-between;
      margin-bottom: 8px; padding: 8px 0;
      border-bottom: 1px solid rgba(81,162,255,0.15);
      position: relative;
      transition: background-color 0.2s ease;
    }
    #infoPanel .property-row:hover { background-color: rgba(81,162,255,0.05); }
    #infoPanel .property-row::before {
      content: "";
      position: absolute; left: -15px; top: 50%;
      transform: translateY(-50%);
      width: 6px; height: 6px;
      background-color: #51a2ff; border-radius: 50%;
      box-shadow: 0 0 5px rgba(81,162,255,0.8);
    }
    #infoPanel .property-name {
      font-weight: 500; color: #51a2ff; font-family: "Orbitron", sans-serif;
      font-size: 13px; letter-spacing: 0.5px; position: relative; padding-right: 10px;
    }
    #infoPanel .property-value {
      color: #e0e7ff; font-family: "Roboto", sans-serif;
      background: rgba(81,162,255,0.05);
      padding: 2px 8px; border-radius: 4px; border-left: 2px solid rgba(81,162,255,0.3);
      min-width: 60px; text-align: center;
    }
    #infoPanel .property-value.numeric { font-family: "Orbitron", sans-serif; letter-spacing: 1px; }

    #infoPanel::-webkit-scrollbar { width: 6px; }
    #infoPanel::-webkit-scrollbar-track { background: rgba(16,20,40,0.5); }
    #infoPanel::-webkit-scrollbar-thumb { background: rgba(81,162,255,0.5); border-radius: 3px; }
    #infoPanel::-webkit-scrollbar-thumb:hover { background: rgba(81,162,255,0.8); }

    /* Type legend panel */
    #legendPanel { bottom: 20px; right: 20px; padding: 10px; font-size: 14px; }
    #legendPanel .header { margin-bottom: 10px; }
    .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
    .legend-color {
      width: 16px; height: 16px; border-radius: 4px; margin-right: 10px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }
    .legend-text { font-size: 13px; }

    /* Name overlay */
    #nameOverlay {
      display: none;
      position: absolute;
      background: rgba(32, 36, 60, 0.8);
      color: #51a2ff;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: "Orbitron", sans-serif;
      font-size: 12px;
      pointer-events: none;
      border: 1px solid rgba(81, 162, 255, 0.5);
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      z-index: 1000;
    }

    /* AI chat panel */
    #aiChatPanel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 350px; height: 400px;
      background: linear-gradient(135deg, rgba(16, 20, 40, 0.95) 0%, rgba(32, 36, 60, 0.95) 100%);
      color: #e0e7ff;
      border-radius: 8px;
      font-family: "Roboto", Arial, sans-serif;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5), 0 0 0 1px rgba(81,162,255,0.2);
      z-index: 999;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(81,162,255,0.3);
      display: flex; flex-direction: column;
    }
    #aiChatPanel::before,
    #aiChatPanel::after {
      content: "";
      position: absolute; top: -1px; left: -1px; right: -1px; bottom: -1px;
      border-radius: 8px; padding: 1px;
      background: linear-gradient(135deg, #51a2ff, #2c76dc, #0f4c9c);
      -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite: xor; mask-composite: exclude;
      pointer-events: none; z-index: -1;
    }
    #aiChatPanel .header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 10px 15px; border-bottom: 1px solid rgba(81,162,255,0.2);
      background: rgba(16, 20, 40, 0.5);
    }
    #aiChatPanel .title {
      font-family: "Orbitron", sans-serif; font-size: 16px; font-weight: 500;
      color: #51a2ff; letter-spacing: 1px; text-shadow: 0 0 10px rgba(81,162,255,0.5);
    }
    #aiChatPanel .minimize-btn {
      cursor: pointer; color: #51a2ff; font-size: 18px;
      width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
      border-radius: 50%; transition: all 0.2s ease;
    }
    #aiChatPanel .minimize-btn:hover { background: rgba(81,162,255,0.2); }
    #aiChatPanel.minimized { height: 45px; }
    #aiChatPanel.minimized .chat-content,
    #aiChatPanel.minimized .chat-input-container,
    #aiChatPanel.minimized .quick-questions { display: none; }

    #aiChatPanel .chat-content {
      height: 250px; overflow-y: auto; padding: 15px;
      display: flex; flex-direction: column;
    }
    #aiChatPanel .chat-content::-webkit-scrollbar { width: 6px; }
    #aiChatPanel .chat-content::-webkit-scrollbar-track { background: rgba(16,20,40,0.5); border-radius: 3px; }
    #aiChatPanel .chat-content::-webkit-scrollbar-thumb { background: rgba(81,162,255,0.5); border-radius: 3px; }

    .message {
      margin-bottom: 10px; max-width: 80%;
      padding: 8px 12px; border-radius: 12px; word-break: break-word;
      animation: fadeIn 0.3s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .user-message {
      align-self: flex-end;
      background: rgba(81,162,255,0.2);
      border: 1px solid rgba(81,162,255,0.3);
      border-bottom-right-radius: 4px;
    }
    .ai-message {
      align-self: flex-start;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-bottom-left-radius: 4px;
    }
    .highlighted-building {
      font-weight: bold; color: #51a2ff; cursor: pointer; text-decoration: underline; transition: color 0.2s ease;
    }
    .highlighted-building:hover { color: #ffffff; text-shadow: 0 0 5px rgba(81,162,255,0.8); }

    .building-card {
      background: rgba(32, 36, 60, 0.8);
      border: 1px solid rgba(81,162,255,0.3);
      border-radius: 8px;
      padding: 10px 15px; margin: 10px 0;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .building-card h3 {
      color: #51a2ff; margin: 0 0 8px 0;
      font-family: "Orbitron", sans-serif; font-size: 16px;
    }
    .building-card ul { list-style: none; padding: 0; margin: 0; }
    .building-card li { margin-bottom: 5px; font-size: 14px; display: flex; justify-content: space-between; }
    .building-card li span:first-child { color: #51a2ff; font-weight: 500; margin-right: 5px; }
    .building-card li span:last-child { color: #e0e7ff; }

    .chat-input-container { display: flex; padding: 10px; border-top: 1px solid rgba(81,162,255,0.2); }
    #chatInput {
      flex: 1; background: rgba(255,255,255,0.05);
      border: 1px solid rgba(81,162,255,0.3);
      border-radius: 4px; color: #e0e7ff; padding: 8px 12px;
      font-family: "Roboto", Arial, sans-serif; font-size: 14px; outline: none;
    }
    #chatInput:focus { border-color: rgba(81,162,255,0.6); box-shadow: 0 0 5px rgba(81,162,255,0.3); }
    #sendButton {
      background: linear-gradient(135deg, #51a2ff, #2c76dc);
      border: none; border-radius: 4px; color: white;
      padding: 8px 15px; margin-left: 8px; cursor: pointer;
      font-family: "Roboto", Arial, sans-serif; font-weight: 500; transition: all 0.2s ease;
    }
    #sendButton:hover { background: linear-gradient(135deg, #61b2ff, #3c86ec); box-shadow: 0 0 10px rgba(81,162,255,0.5); }
    #sendButton:active { transform: scale(0.98); }

    .quick-questions { display: flex; flex-wrap: wrap; gap: 8px; padding: 10px; border-top: 1px solid rgba(81,162,255,0.2); }
    .quick-question-btn {
      background: rgba(81,162,255,0.1);
      border: 1px solid rgba(81,162,255,0.3);
      border-radius: 15px; color: #e0e7ff;
      padding: 5px 10px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;
    }
    .quick-question-btn:hover { background: rgba(81,162,255,0.2); border-color: rgba(81,162,255,0.5); }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>

  <!-- Name overlay -->
  <div id="nameOverlay"></div>

  <!-- Info panel -->
  <div id="infoPanel" class="panel">
    <button class="close-btn">X</button>
    <div class="header">Attribute Information</div>
    <div id="propertyContent"></div>
  </div>

  <!-- Type legend panel -->
  <div id="legendPanel" class="panel">
    <div class="header">Type Legend</div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #4287f5"></div>
      <div class="legend-text">Commercial Office</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #f542a7"></div>
      <div class="legend-text">Commercial Retail</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background-color: #42f5b3"></div>
      <div class="legend-text">Other Businesses</div>
    </div>
  </div>

  <!-- AI chat panel -->
  <div id="aiChatPanel" class="panel">
    <div class="header">
      <div class="title">AI Assistant</div>
      <div class="minimize-btn">—</div>
    </div>
    <div class="chat-content" id="chatContent"></div>
    <div class="chat-input-container">
      <input type="text" id="chatInput" placeholder="Ask me anything about the map..." />
      <button id="sendButton" type="button">Send</button>
    </div>
    <div class="quick-questions">
      <button class="quick-question-btn">Tallest building?</button>
      <button class="quick-question-btn">Largest building?</button>
      <button class="quick-question-btn">Shortest building?</button>
    </div>
  </div>

  <script>
    // App config
    const CONFIG = {
      cesiumToken:
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiMzIxNmVlMS0yNGRkLTRiOTgtYWE2Yy1mZTAwM2VkMTIyNzAiLCJpZCI6MTE3MDI0LCJpYXQiOjE3MjAwNTY4MDJ9.hZHosKirb0ePrJHy85NJbm83pORMcjusq_Ga2rFXCTU",
      mapboxToken:
        "pk.eyJ1Ijoid2VpeWFuc2hlbmciLCJhIjoiY2xwbTFjNnlrMDVndzJpbWZtZjRvY3JqZyJ9.3iKZK8y9yVHMnaqonFHE_g",
      tilesetPath: "./tiles/tileset.json", // update if your path differs
      commerceTypes: ["commerce", "commerce:office", "commerce:retail"],
      colors: {
        office: "#4287f5",
        retail: "#f542a7",
        other: "#42f5b3",
        highlight: "#fffb00",
      },
      // External AI API keys present here will work locally but avoid committing them publicly.
      openaiApiKey: "sk-ae8d5a79fdad4b9bb60a887e1765e089",
      openaiBaseUrl: "https://api.deepseek.com",
      moonshotApiKey: "sk-amviNvUduDf5ZULn5rI3GBM6WPcjXgNAF9tKQL8ggnPLhuSu",
      moonshotBaseUrl: "https://api.moonshot.cn",
    };

    Cesium.Ion.defaultAccessToken = CONFIG.cesiumToken;

    const viewer = new Cesium.Viewer("cesiumContainer", {
      geocoder: false,
      homeButton: false,
      sceneModePicker: false,
      baseLayerPicker: false,
      imageryProvider: false,
      navigationHelpButton: false,
      animation: false,
      timeline: false,
      fullscreenButton: false,
      vrButton: false,
      infoBox: false,
      selectionIndicator: false,
    });

    // Add Mapbox basemap
    viewer.imageryLayers.addImageryProvider(
      new Cesium.UrlTemplateImageryProvider({
        url: `https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/256/{z}/{x}/{y}?access_token=${CONFIG.mapboxToken}`,
      })
    );

    // Hide credits and enable depth test
    viewer.cesiumWidget.creditContainer.style.display = "none";
    viewer.scene.globe.depthTestAgainstTerrain = true;
    viewer.scene.debugShowFramesPerSecond = true;

    // DOM elements
    const elements = {
      infoPanel: document.getElementById("infoPanel"),
      propertyContent: document.getElementById("propertyContent"),
      closeBtn: document.querySelector("#infoPanel .close-btn"),
      nameOverlay: document.getElementById("nameOverlay"),
      chatContent: document.getElementById("chatContent"),
      chatInput: document.getElementById("chatInput"),
      sendButton: document.getElementById("sendButton"),
      quickQuestionBtns: document.querySelectorAll(".quick-question-btn"),
      aiChatPanel: document.getElementById("aiChatPanel"),
      minimizeBtn: document.querySelector("#aiChatPanel .minimize-btn"),
    };

    // State
    let buildingsData = [];
    let highlightedEntities = [];
    let selectedEntity = null;
    let currentHighlightedBuilding = null;

    const highlighted = { feature: undefined, originalColor: new Cesium.Color() };

    // Close info panel
    elements.closeBtn.addEventListener("click", () => {
      elements.infoPanel.classList.remove("visible");
      setTimeout(() => { elements.infoPanel.style.display = "none"; }, 300);
    });

    // Minimize chat
    elements.minimizeBtn.addEventListener("click", function () {
      elements.aiChatPanel.classList.toggle("minimized");
      this.textContent = elements.aiChatPanel.classList.contains("minimized") ? "+" : "—";
    });

    // Utils
    const utils = {
      isCommerceType(type) { return CONFIG.commerceTypes.includes(type); },

      toggleInfoPanel(show, properties) {
        if (show && properties) {
          this.showPropertyInfo(properties);
          elements.infoPanel.style.display = "block";
          setTimeout(() => elements.infoPanel.classList.add("visible"), 10);
        } else {
          elements.infoPanel.classList.remove("visible");
          setTimeout(() => (elements.infoPanel.style.display = "none"), 300);
        }
      },

      showPropertyInfo(properties) {
        elements.propertyContent.innerHTML = "";
        if (!properties || Object.keys(properties).length === 0) {
          elements.propertyContent.innerHTML = '<div class="property-row">No available attributes</div>';
          return;
        }
        for (const key in properties) {
          if (Object.prototype.hasOwnProperty.call(properties, key)) {
            const value = properties[key];
            if (value !== undefined && value !== null) {
              const row = document.createElement("div");
              row.className = "property-row";

              const nameSpan = document.createElement("span");
              nameSpan.className = "property-name";
              nameSpan.textContent = key;

              const valueSpan = document.createElement("span");
              valueSpan.className = "property-value";
              if (!isNaN(parseFloat(value)) && isFinite(value)) valueSpan.classList.add("numeric");
              valueSpan.textContent = value;

              row.appendChild(nameSpan);
              row.appendChild(valueSpan);
              elements.propertyContent.appendChild(row);
            }
          }
        }
        elements.infoPanel.style.display = "block";
        setTimeout(() => { elements.infoPanel.classList.add("visible"); }, 10);
      },

      updateNameOverlay(pickedFeature, position) {
        if (!Cesium.defined(pickedFeature)) {
          elements.nameOverlay.style.display = "none";
          return;
        }
        elements.nameOverlay.style.display = "block";
        elements.nameOverlay.style.bottom = `${viewer.canvas.clientHeight - position.y}px`;
        elements.nameOverlay.style.left = `${position.x}px`;

        const id = pickedFeature.getProperty("_id");
        elements.nameOverlay.textContent = id ? `ID: ${id}` : "No ID";
      },

      highlightFeature(pickedFeature) {
        if (Cesium.defined(highlighted.feature)) {
          highlighted.feature.color = Cesium.Color.clone(highlighted.originalColor, highlighted.feature.color);
        }
        if (Cesium.defined(pickedFeature)) {
          highlighted.feature = pickedFeature;
          Cesium.Color.clone(pickedFeature.color, highlighted.originalColor);
          pickedFeature.color = Cesium.Color.YELLOW;
        } else {
          highlighted.feature = undefined;
        }
      },

      getFeatureProperties(pickedFeature) {
        if (!Cesium.defined(pickedFeature)) return null;
        const propertyIds = pickedFeature.getPropertyIds();
        const properties = {};
        propertyIds.forEach((pid) => { properties[pid] = pickedFeature.getProperty(pid); });
        return properties;
      },
    };

    // Load 3D tileset
    async function addTileset() {
      try {
        const tileset = await Cesium.Cesium3DTileset.fromUrl(CONFIG.tilesetPath, {
          maximumScreenSpaceError: 8,
          maximumMemoryUsage: 1024,
        });
        viewer.scene.primitives.add(tileset);

        tileset.style = new Cesium.Cesium3DTileStyle({
          show: CONFIG.commerceTypes.map((type) => `\${type} === '${type}'`).join(" || "),
          color: {
            conditions: [
              ["\${type} === 'commerce:office'", `color('${CONFIG.colors.office}', 0.8)`],
              ["\${type} === 'commerce:retail'", `color('${CONFIG.colors.retail}', 0.8)`],
              ["\${type} === 'commerce'", `color('${CONFIG.colors.other}', 0.8)`],
              [true, "color('gray', 0.0)"],
            ],
          },
        });

        viewer.zoomTo(tileset);
      } catch (error) {
        console.error(`Failed to load 3D Tileset: ${error.message}`);
        alert("Failed to load 3D model. Please check network connection or model path.");
      }
    }

    // Events
    function setupEventHandlers() {
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

      handler.setInputAction(function (click) {
        const pickedFeature = viewer.scene.pick(click.position);
        const isTileFeature = Cesium.defined(pickedFeature) && pickedFeature instanceof Cesium.Cesium3DTileFeature;

        if (isTileFeature) {
          const earthPosition = viewer.scene.pickPosition(click.position);
          const cartographic = Cesium.Cartographic.fromCartesian(earthPosition);
          const lon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(5);
          const lat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(5);

          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(lon, lat, 3000),
            duration: 2,
            orientation: { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-90), roll: 0 },
          });
        }

        if (isTileFeature) {
          const properties = utils.getFeatureProperties(pickedFeature);
          utils.highlightFeature(pickedFeature);
          utils.toggleInfoPanel(utils.isCommerceType(properties.type), properties);
        } else {
          utils.highlightFeature(null);
          utils.toggleInfoPanel(false);
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      handler.setInputAction(function (movement) {
        const pickedFeature = viewer.scene.pick(movement.endPosition);
        const isTileFeature = Cesium.defined(pickedFeature) && pickedFeature instanceof Cesium.Cesium3DTileFeature;

        if (isTileFeature) {
          utils.highlightFeature(pickedFeature);
          utils.updateNameOverlay(pickedFeature, movement.endPosition);
        } else {
          utils.updateNameOverlay(null);
        }
      }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
    }

    // Init
    async function init() {
      await addTileset();
      setupEventHandlers();
      addWelcomeMessage();
    }

    // Chat helpers
    function addWelcomeMessage() {
      const message = document.createElement("div");
      message.className = "message ai-message";
      message.textContent = "Hello, I am Poppy. Ask me anything!";
      chatContent.appendChild(message);
      scrollToBottom();
    }
    function addUserMessage(text) {
      const message = document.createElement("div");
      message.className = "message user-message";
      message.textContent = text;
      chatContent.appendChild(message);
      scrollToBottom();
    }
    function addAIMessage(text) {
      const message = document.createElement("div");
      message.className = "message ai-message";
      message.innerHTML = text;
      chatContent.appendChild(message);
      scrollToBottom();

      const highlightedBuildings = message.querySelectorAll(".highlighted-building");
      highlightedBuildings.forEach((el) => {
        el.addEventListener("click", function () {
          const buildingName = this.textContent;
          const buildingId = this.getAttribute("data-id");
          focusOnBuilding(buildingName, buildingId);
        });
      });
    }
    function scrollToBottom() { chatContent.scrollTop = chatContent.scrollHeight; }

    function handleUserInput() {
      const userText = chatInput.value.trim();
      if (userText === "") return;
      chatInput.value = "";
      addUserMessage(userText);
      processUserQuery(userText);
    }

    // Query processing
    async function processUserQuery(query) {
      clearBuildingHighlight();

      const loadingMessage = document.createElement("div");
      loadingMessage.className = "message ai-message";
      loadingMessage.textContent = "Thinking...";
      chatContent.appendChild(loadingMessage);
      scrollToBottom();

      try {
        const response = await fetch(`http://localhost:3000/api/chat`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });

        if (!response.ok) throw new Error(`API request failed: ${response.status}`);
        const data = await response.json();

        let aiResponse;
        if (data && data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
          aiResponse = data.choices[0].message.content;

          try {
            const parsedContent = JSON.parse(aiResponse);
            if (parsedContent && parsedContent.type === "FeatureCollection" && parsedContent.features) {
              window.cachedBuildingData = parsedContent;
            }
          } catch { /* not JSON, fine */ }

          chatContent.removeChild(loadingMessage);
          const processedResponse = processAIResponse(aiResponse);
          addAIMessage(processedResponse);
          highlightBuildingsFromResponse(aiResponse);
        } else {
          chatContent.removeChild(loadingMessage);
          addAIMessage("Sorry, there was an issue processing your request. The API response format was unexpected.");
          return;
        }
      } catch (error) {
        console.error("API error:", error);
        if (loadingMessage.parentNode) chatContent.removeChild(loadingMessage);
        addAIMessage("Sorry, I ran into a problem. Please check your network or try again later. You can ask about Dubai buildings (e.g., tallest, largest by area, etc.).");
      }
    }

    function createBuildingCard(id, name, props) {
      return `<div class="building-card">
          <h3><span class="highlighted-building" data-id="${id}">${name}</span></h3>
          <ul>
            ${props.type ? `<li><span>Type:</span> <span>${props.type}</span></li>` : ""}
            ${props.height ? `<li><span>Height:</span> <span>${props.height} m</span></li>` : ""}
            ${props.area ? `<li><span>Area:</span> <span>${props.area} m²</span></li>` : ""}
            ${props.levels ? `<li><span>Floors:</span> <span>${props.levels}</span></li>` : ""}
            ${props.date ? `<li><span>Date:</span> <span>${props.date}</span></li>` : ""}
          </ul>
        </div>`;
    }

    function processAIResponse(response) {
      try {
        const jsonRegex = /```json\s*([\s\S]*?)\s*```/g;
        let match; let hasProcessedJson = false;

        while ((match = jsonRegex.exec(response)) !== null) {
          const jsonContent = match[1].trim();
          try {
            const buildingData = JSON.parse(jsonContent);
            let htmlContent = "";
            let features = [];

            if (Array.isArray(buildingData)) features = buildingData;
            else if (buildingData.type === "FeatureCollection" && buildingData.features) features = buildingData.features;
            else if (buildingData.type === "Feature") features = [buildingData];

            features.forEach((item) => {
              if (item.type === "Feature" && item.properties) {
                const props = item.properties;
                const id = props.id;
                const name = props.name || "Unnamed Building";
                htmlContent += createBuildingCard(id, name, props);
              }
            });

            if (htmlContent) {
              response = response.replace(match[0], htmlContent);
              hasProcessedJson = true;
            }
          } catch (jsonError) {
            console.error("JSON parse failed:", jsonError);
          }
        }

        if (!hasProcessedJson) {
          try {
            const buildingData = JSON.parse(response.trim());
            let htmlContent = "";
            let features = [];

            if (Array.isArray(buildingData)) features = buildingData;
            else if (buildingData.type === "FeatureCollection" && buildingData.features) features = buildingData.features;
            else if (buildingData.type === "Feature") features = [buildingData];

            features.forEach((item) => {
              if (item.type === "Feature" && item.properties) {
                const props = item.properties;
                const id = props.id;
                const name = props.name || id;
                htmlContent += createBuildingCard(id, name, props);
              }
            });

            if (htmlContent) response = htmlContent;
          } catch { /* not JSON; continue as text */ }
        }
      } catch (err) {
        console.error("Failed to process JSON content:", err);
      }

      if (window.cachedBuildingData && window.cachedBuildingData.features) {
        window.cachedBuildingData.features.forEach((feature) => {
          if (feature.properties && feature.properties.name) {
            const name = feature.properties.name;
            const id = feature.properties.id;
            if (name && response.includes(name)) {
              const highlightedPattern = new RegExp(`<span class="highlighted-building"[^>]*>${name}</span>`);
              if (!highlightedPattern.test(response)) {
                response = response.replace(
                  new RegExp(name, "g"),
                  `<span class="highlighted-building" data-id="${id}">${name}</span>`
                );
              }
            }
          }
        });
      }
      return response;
    }

    function highlightBuildingsFromResponse(response) {
      const idRegex = /data-id="([^"]+)"/g;
      let match; const buildingIds = [];
      while ((match = idRegex.exec(response)) !== null) buildingIds.push(match[1]);

      if (buildingIds.length > 0 && window.cachedBuildingData && window.cachedBuildingData.features) {
        const foundFeatures = [];
        buildingIds.forEach((id) => {
          const feature = window.cachedBuildingData.features.find((f) => f.properties && f.properties.id === id);
          if (feature) foundFeatures.push(feature);
        });

        if (foundFeatures.length > 0) {
          highlightBuildingByStyle(foundFeatures[0].properties.id);

          const bounds = calculateBounds(foundFeatures);
          viewer.camera.flyTo({
            duration: 1.5,
            orientation: { heading: Cesium.Math.toRadians(0), pitch: Cesium.Math.toRadians(-90), roll: 0 },
          });
        }
      }
    }

    function calculateBounds(features) {
      let west = Infinity, south = Infinity, east = -Infinity, north = -Infinity;
      features.forEach((feature) => {
        if (feature.geometry && feature.geometry.coordinates) {
          const coordinates = feature.geometry.coordinates[0];
          coordinates.forEach((coord) => {
            west = Math.min(west, coord[0]);
            east = Math.max(east, coord[0]);
            south = Math.min(south, coord[1]);
            north = Math.max(north, coord[1]);
          });
        }
      });
      return { west, south, east, north };
    }

    function focusOnBuilding(buildingName, buildingId) {
      let foundFeature = null;
      if (window.cachedBuildingData && window.cachedBuildingData.features) {
        foundFeature = window.cachedBuildingData.features.find((feature) => {
          if (feature.properties) {
            if (buildingId && feature.properties.id === buildingId) return true;
            if (buildingName && feature.properties.name === buildingName) return true;
          }
          return false;
        });
      }

      if (foundFeature) {
        utils.showPropertyInfo(foundFeature.properties);
        elements.infoPanel.style.display = "block";
        setTimeout(() => elements.infoPanel.classList.add("visible"), 10);

        if (foundFeature.geometry && foundFeature.geometry.coordinates) {
          const coordinates = foundFeature.geometry.coordinates[0];
          let centerLon = 0, centerLat = 0;
          coordinates.forEach((c) => { centerLon += c[0]; centerLat += c[1]; });
          centerLon /= coordinates.length; centerLat /= coordinates.length;

          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(centerLon, centerLat, 1000),
            duration: 1.5,
            orientation: { heading: 0, pitch: Cesium.Math.toRadians(-90), roll: 0 },
          });
        }

        highlightBuildingByStyle(foundFeature.properties.id);
      } else {
        console.warn("No matching building found.");
      }
    }

    elements.sendButton.addEventListener("click", handleUserInput);
    elements.chatInput.addEventListener("keypress", function (event) {
      if (event.key === "Enter") { event.preventDefault(); handleUserInput(); }
    });
    elements.quickQuestionBtns.forEach((btn) => {
      btn.addEventListener("click", function () {
        const question = this.textContent;
        elements.chatInput.value = question;
        handleUserInput();
      });
    });

    function highlightBuildingByStyle(buildingId) {
      clearBuildingHighlight();
      const tileset = viewer.scene.primitives.get(0);
      if (tileset && tileset instanceof Cesium.Cesium3DTileset) {
        tileset.style = new Cesium.Cesium3DTileStyle({
          show: CONFIG.commerceTypes.map((type) => `\${type} === '${type}'`).join(" || "),
          color: {
            conditions: [
              [`\${id} === '${buildingId}' || \${_id} === '${buildingId}'`, `color('${CONFIG.colors.highlight}', 1.0)`],
              ["\${type} === 'commerce:office'", `color('${CONFIG.colors.office}', 0.8)`],
              ["\${type} === 'commerce:retail'", `color('${CONFIG.colors.retail}', 0.8)`],
              ["\${type} === 'commerce'", `color('${CONFIG.colors.other}', 0.8)`],
              [true, "color('gray', 0.0)"],
            ],
          },
        });
        currentHighlightedBuilding = buildingId;
      }
    }

    function clearBuildingHighlight() {
      const tileset = viewer.scene.primitives.get(0);
      if (tileset && tileset instanceof Cesium.Cesium3DTileset) {
        tileset.style = new Cesium.Cesium3DTileStyle({
          show: CONFIG.commerceTypes.map((type) => `\${type} === '${type}'`).join(" || "),
          color: {
            conditions: [
              ["\${type} === 'commerce:office'", `color('${CONFIG.colors.office}', 0.8)`],
              ["\${type} === 'commerce:retail'", `color('${CONFIG.colors.retail}', 0.8)`],
              ["\${type} === 'commerce'", `color('${CONFIG.colors.other}', 0.8)`],
              [true, "color('gray', 0.0)"],
            ],
          },
        });
        currentHighlightedBuilding = null;
      }
    }

    init();
  </script>
</body>
</html>
